c
no_of_pages_per_student
no_of_pages_perstudent
students.length 
c
n
exam.test_givers
exam
c
continue
c
vari.update(question_chart_json(question)) { |k,v1,v2| v1+v2 }
vari
cari
c
vari
c
var
c
marks[0].next
marks[0]
a[0]
marks
rolls
c
Hash[rolls.zip marks.zip]
Hash[rolls.zip marks]
rolls.count
rolls
marks.length
marks
c
@jobs.map(&:grade).each { |f| f.nil?  }.length
@jobs.map(&:grade).each { |f| f.nil?  }
@jobs.map(&:grade).each { |f| f.nil? "I am here" }
@jobs.map(&:grade).each { |f| f.nil ? puts "I am here" }
@jobs.map(&:grade).each { |f| f.nil ? puts "I am here" : ""  }
@jobs.map(&:grade).each { |f| f.nil ? puts "I am here" :   }
@jobs.map(&:grade).each { |f| if f.nil? puts "I am here" end }
@jobs.map(&:grade).each { |f| if f.nil? puts "I am here" }
@jobs.map(&:grade).each do {|f| if f.nil? puts "I am here" }
@jobs.map(&:grade)
@jobs.grade
@jobs.grades
@jobs.map(&:grade).each do |g|
@jobs.map(&:grade).each do 
@jobs.map(&:grade)
@jobs
c
@job.grade
c
@grade.save
@grade
c
post_grade_params
c
a.split(',').map(&:to_i)
a.split(',')
a = post_grade_params[:assigned_marks]
post_grade_params[:assigned_marks]
post_grade_params[:assigned_marks].to_a
post_grade_params[:assigned_marks].map(&:to_i)
post_grade_params[:assigned_marks].map(:&:to_i)
post_grade_params[:assigned_marks]
post_grade_params
c
@grade.assigned_marks = Array.new(2)
@grade.assigned_marks
c
@grade.assigned_marks
@grade = Grade.new
B@grade = Grade.new
@grade.assigned_marks
@grade.teacher
@grade.id
@grade.assigned_marks
@grade
@grade.assigned_marks
@pqs.count
@pqs
c
current_index
c
@job.link_array(current_teacher.id, @exam).index(@job.id.to_s)
@job.link_array(current_teacher.id, @exam).find(@job.id).index
@job.link_array(current_teacher.id, @exam).find(@job.id)
@job.link_array(current_teacher.id, @exam)
c
@job.link_array(current_teacher.id, @exam)
c
Job.reload
@job.link_array(current_teacher.id, @exam)
@job
c
self.link_array(self.teacher.id, @exam)
self.link_arrays(self.teacher.id, @exam)
self.teacher
self
current_teacher
self.link_arrays(current_teacher.id, @exam)
self.class
self
c
st == stored_links
st = @jobs.pluck(:id).map(&:to_s) 
@jobs.pluck(:id).map(&:to_s) == stored_links
@jobs.pluck(:id).map(&:to_s)
stored_links = Job.first.link_array(current_teacher.id, @exam.id).pluck(:id).map(&:to_s)
Job.first.link_array(current_teacher.id, @exam.id).pluck(:id).map(&:to_s)
Job.first.link_array(current_teacher.id, @exam.id).pluck(:id)
Job.first.link_array(current_teacher.id, @exam.id)
Job.link_array(current_teacher.id, @exam.id)
Job.link_array(current_teacher.id)
c
Job.reload
Reload!
reload
@jobs.first.link_array(current_teacher.id)
@jobs.first.link_array(current_teacher)
@jobs.first
@job
Job.next
Job.link_array(current_teacher)
Job.link_array(current_teacher, @exam)
current_teacher.id
current_teacher
current_teacehr
current_user
Job.link_array
@jobs.pluck(:_id).map(&:to_s)
@jobs.pluck(:_id).map(:to_s)
@jobs.pluck(:_id).to_s
@jobs.pluck(:_id)
@jobs.pluck(:id)
@jobs
c
Job.next(Teacher.first.id)
Job.next
c
split_images.length
split_images
c
pages.count
c
pages.length
pages
quit
c
run
c
v
c
n
pages_subset = pages[page_shift..(page_shift + no_of_pages_per_student)-1]
pages_subset
n
pages[page_shift..(page_shift + no_of_pages_per_student)-1].length
pages[page_shift..(page_shift + no_of_pages_per_student)-1]
n
pages
pages_subset
page_shift
quit
page_shift
c
cc
c
run
c
pages[page_shift..(page_shift + no_of_pages_per_student)-1].length
pages[page_shift..(page_shift + no_of_pages_per_student)-1]
pages_subset
c
(page_shift + no_of_pages_per_student)
(page_shift + no_of_pages_per_student)-1
page_shift
n
no_of_pages_per_student
page_shift
pages[page_shift..(page_shift + no_of_pages_per_student)].length
pages[page_shift..(page_shift + no_of_pages_per_student)]
pages_subset
n
pages_subset
quit
continue
run
r
pages_subset
c
pages_subset = 0
pages_subset
c
exam.questions.count
exam.questions
exam
exam.test_givers.count
exam.test_givers
exam.test_papers
exam.test_papers.path
exam.test_papers
exam.file.path
exam
